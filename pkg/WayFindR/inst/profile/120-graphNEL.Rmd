---
title: "Converting igraph to  graphNEL"
author: "Kevin R. Coombes"
date: '`r Sys.Date()`'
output: 
  html_document:
    theme: simplex
    highlight: tango
    toc: yes
  pdf_document:
    highlight: tango
    toc: yes
---

```{r setup, include=FALSE, results="hide"}
knitr::opts_chunk$set(echo = TRUE, fig.width=6, fig.height=6, dev = "png")
options(width = 96)

.format <- knitr::opts_knit$get("rmarkdown.pandoc.to")
.format <- ifelse(is.null(.format), "html", .format)
.tag <- function(N, cap ) ifelse(.format %in% c("html", "docx"),
                                 paste("Figure ", N, ": ",  cap, sep = ""),
                                 cap)
```
```{r mycss, results="asis", echo=FALSE}
cat('
<style type="text/css">
b, strong {color: red; }
i, em {color: blue; }
.defn {color: purple; }
.para {color: purple;
      font-weight: bold;
}
.figure { text-align: center; }
.caption { font-weight: bold; }
</style>
')
```

# Background
R contains two fundamental ways to deal with mathematical graphs, both of which include
interfaces to more general suites of algorithms with interfaces from multiple languages:

1. The `graph` and `Rgraphviz` packages, from BioConductor, primarily use an S4 class 
   structure known as `graphNEL`. This contains more detailed visualization tools, in 
   terms of the shape of nodes/vertices and the style of edges.
2. The `igraph` package uses its own S3 class structure. Its main focus is on a wide
   variety of graph algorithms from compute science. It has more "graph layout" options
   than `Rgraphviz`, but fewer node shapes.

Our work on WikiPathways so far has allowed us to convert WikiPathways from their KGML
file format to `igraph` classes in R, Here, we want to explore whether we can convert 
from `igraph` to `graphNEL` in order to exploit the wider array of node shapes and other
visualization tools.

# Getting Started
We begin, as usual, by loading a collection of potentially useful packages.
```{r packs}
library(WayFindR)
library(igraph)
if (!requireNamespace("graph", quietly = TRUE)) {
  BiocManager::install("graph", update = FALSE, ask = FALSE)
}
library(graph)
if (!requireNamespace("Rgraphviz", quietly = TRUE)) {
  BiocManager::install("Rgraphviz", update = FALSE, ask = FALSE)
}
library(Rgraphviz)
```

# An Example Graph
Now we load an exampel graph from WikiPathways, and convert it into an `igraph` object using tools
from our `WayFindR` package.
```{r example}
xmlfile <- system.file("pathways/WP3850.gpml", package = "WayFindR")
G <- GPMLtoIgraph(xmlfile)
```
We convert "circle" to "ellipses" to make visualuizaitons better.
```{r reshape}
wc <- which(V(G)$shape == "circle")
G <- set_vertex_attr(G, "shape", index = wc, value = "ellipse")
```
Now we plot the `igraph` object using our current favorite "two-step layout" method (**Figure 1**). 
Note that we need to call "plot.new" before we can compute string sizes.
```{r fig01, fig.width=12, fig.height=12, fig.cap=.tag(1, "WikiPathways human pathway WP3850."), fig.keep='last'}
plot(0,0, type = "n")
opar <- par(mai = c(0.05, 0.05, 1, 0.05))
sz <- (strwidth(V(G)$label) + strwidth("oo")) * 92
G <- set_vertex_attr(G, "size", value = sz)
G <- set_vertex_attr(G, "size2", value = strheight("I") * 2 * 92)
set.seed(12345)
L <- layout_nicely(G)
L2 <- layout_with_kk(G, coords=L)
plot(G, layout = L2)
title("Two-step layout algorithm")
edgeLegend("bottomleft", G)
nodeLegend("bottomright", G)
par(opar)
```

# Exploring Rgraphviz
We use a function from the `igraph` package to convert our graph into the `graphNEL` format.
```{r GN}
GN <- as_graphnel(G)
slotNames(GN)
```
```{r nodeData}
GN@graphData
graph_attr(G)
```
The "graph-level" data has been transferred successfully.

## Node Data
```{r nodestuff}
GN@nodes
slotNames(GN@nodeData)
GN@nodeData@data[[1]]
```
We see that the node names have been included in the conversion, and the information we want to use to
display the nodes has been slurped into the `nodeData` slot.

## Edge Data
```{r edgestuff}
head(GN@edgeL, 3)
slotNames(GN@edgeData)
GN@edgeData@data[1:2]
```
The `edgeL` slot uses a different format than we are used to for each node, it fives the internal 
numerical ids of the edges that start there. The display information for nodes has also been transferred 
over to the `edgeData` slot. Notice, however that the edge names here are of the form "id1|id2", where the
node ides are separated by a vertical bar. (The documentation in some part of the Rgraphviz package says
that you should use the symbol "~".) In the `igraph` version, the separator is an ASCII arrow "->", as seen
here:
```{r igraphEdge}
E(G)[1:3]
```

## Render Info
Now notice that the `renderInfo` slot is a highly structured form of "nothing":
```{r moreGN}
GN@renderInfo
```

## First GraphNEL Plot
Now we can try the simplest possible way to plot the `graphNEL` object (**Figure 2**).
Not surprisingly, since the display/rendering info has been stuffed into the data
annotation slots, it is ignored during rendering. 

```{r fig02, fig.width=12, fig.height=12, fig.cap=.tag(2,"Simple Rgraphviz plot")}
plot(GN)
```

## Moving Render Info to the Right (?) Place
First, we structure and port the node attributes.
```{r nAttrs}
nms <- vertex_attr(G, "name")
lbl <- vertex_attr(G, "label")
shp <- vertex_attr(G, "shape")
col <- vertex_attr(G, "color")
fix <- rep(FALSE, length(nms))
names(lbl) <- names(shp) <- names(col) <- names(fix) <- nms
nAttrs <- list(label = lbl, shape = shp,
               fixedsize = fix, fillcolor = col)
nodeRenderInfo(GN) <- nAttrs
```
Next, we do the same for the edge attributes.
```{r eAttrs}
enms <- sub("\\|", "~", as_ids(E(G)))
if (!all(edgeNames(GN) %in% enms)) stop("unknown edge name.")
col <- edge_attr(G, "color")
lty <- edge_attr(G, "lty")
names(col) <- names(lty) <- enms
eAttrs <- list(color = col[edgeNames(GN)],
               style = lty[edgeNames(GN)])
edgeRenderInfo(GN) <- eAttrs
```

IN (**Figure 3**), we use the external attributes to display the plot. 
```{r fig03, fig.width=12, fig.height=12, fig.cap=.tag(3,"Second (but stupid) Rgraphviz plot.")}
plot(GN, nodeAttrs = nAttrs, edgeAttrs = eAttrs,
     attrs = list(edge = list(lwd = 3)))
par(lwd=3)
edgeLegend("bottomleft", G)
par(lwd = 1, cex = 1.3)
nodeLegend("topright", G)
```

## Other Approaches
Our objection to **Figure 3** isn't the plot, but the manner in which we need to achieve
it. The display information is now part of the `renderInfo` slot, but seems to be ignored
unless you explicitly pass it along tot he plot function. I don't see why a user of the
`WayFindR` package should have to learn how to do that. There must be a better way.

```{r aargh}
nm <- paste(GN@graphData$PathID, GN@graphData$Name, sep = ": ")
aarg <- agopen(GN, name = nm, layout = TRUE, layoutType = "dot", 
            attrs = list(edge = list(lwd = 3)), 
            nodeAttrs = nAttrs, edgeAttrs = eAttrs)
class(aarg)
```

```{r fig04, fig.width=12, fig.height=12, fig.cap=.tag(4,"Third, more user-friendly, Rgraphviz plot.")}
plot(aarg)
```

There is an alternative interface to achieve the same goal.
```{r fig05, fig.width=12, fig.height=12, fig.cap=.tag(5,"Fourth Rgraphviz plot.")}
L <- layoutGraph(GN, edgeAttrs = eAttrs, nodeAttrs = nAttrs,
                 attrs = list(edge = list(lwd = 3)))
renderGraph(L)
```

Honestly, I don't understand why using `nodeRenderInfo` and `edgeRenderInfo` to put the 
information into the graphNEL object doesn't work.

## Make The User Happy

```{r fig06, fig.width=12, fig.height=12, fig.cap=.tag(5,"Hiding Rgraphviz from the user.")}
source("11-graphNEL.R")
RA <- as.graphNEL(G)
plot(RA)
```

# Appendix

This analysis was performed in the following R environment:
```{r si}
sessionInfo()
```
It was also performed at the following on-disk location:
```{r cwd}
getwd()
```